using CD2C.Common;
using DiagramDesigner;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CD2C
{
    public class CodeGeneratorService : ICodeGeneratorService
    {
        public string GenerateCode(DiagramViewModel diagramViewModel)
        {
            var sbCode = new StringBuilder();
            var connections = diagramViewModel.Items.OfType<ConnectorViewModel>();

            sbCode.AppendLine("//C++ class generated by CD2C(MC200202999)");
            sbCode.AppendLine("using namespace std;");
            sbCode.AppendLine();

            foreach (var classViewModel in diagramViewModel.Items.OfType<ClassDesignerItemViewModel>())
            {
                var parentClassName = connections.
                    Where(con =>
                        con.SourceConnectorInfo.DataItem == classViewModel &&
                        con.SinkConnectorInfo is FullyCreatedConnectorInfo &&
                        con.IsFullConnection
                    ).
                    Select(con => ((con.SinkConnectorInfo as FullyCreatedConnectorInfo).DataItem as ClassDesignerItemViewModel).ClassName).
                    FirstOrDefault();

                string classCode = GenerateClass(classViewModel.ClassName, parentClassName, classViewModel.Methods, classViewModel.DataMembers);

                sbCode.AppendLine(classCode);
                sbCode.AppendLine();
            }

            return sbCode.ToString();
        }

        public string GenerateClass(string className, string parentClassName, IEnumerable<MethodModel> methods, IEnumerable<DataMemberModel> dataMembers)
        {
            //Find unique scopes
            var allScopes = methods.Select(m => m.Scope).ToList();
            allScopes.AddRange(dataMembers.Select(dm => dm.Scope));
            allScopes = allScopes.Distinct().ToList();

            //Builder thats used to generate code as its best to create long string and has good formatting functions.
            var sbOutput = new StringBuilder();

            sbOutput.Append(string.Format("class {0}", className));
            
            if (!string.IsNullOrEmpty(parentClassName))
            {
                sbOutput.Append(string.Format(" : public {0}", parentClassName));
            }

            sbOutput.AppendLine();
            sbOutput.AppendLine("{");

            foreach (var scope in allScopes)
            {
                sbOutput.AppendLine(string.Format("\t{0}:", scope.ToString().ToLower()));

                //find all members and methods of the current scope
                var scopeDataMembers = dataMembers.Where(dm => dm.Scope == scope).ToList();
                var scopeMethods = methods.Where(dm => dm.Scope == scope).ToList();

                foreach (var dm in scopeDataMembers)
                {
                    sbOutput.AppendLine(string.Format("\t\t{0} {1};", GetProperTypeName(dm.Type), dm.Name));
                }

                foreach (var m in scopeMethods)
                {
                    var rows = m.InputParameters.Select(kv => string.Format("{1} {0}", kv.Name, kv.InputType.ToString().Replace("Type", string.Empty))).ToList();
                    var iParams = string.Join(", ", rows);

                    sbOutput.AppendLine(string.Format("\t\t{0} {1} ({2})", GetProperTypeName(m.ReturnType), m.Name, iParams));
                    sbOutput.AppendLine("\t\t{");
                    sbOutput.AppendLine();
                    sbOutput.AppendLine("\t\t}");
                }

                sbOutput.AppendLine();
            }


            sbOutput.AppendLine("};");

            return sbOutput.ToString();
        }

        string GetProperTypeName(TypeEnum typeEnum)
        {
            return typeEnum.ToString().Replace("Type", string.Empty).ToLower();
        }
    }
}
