using CD2C.Common;
using DiagramDesigner;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CD2C
{
    public class CodeGeneratorService : ICodeGeneratorService
    {
        public string GenerateCode(DiagramViewModel diagramViewModel)
        {
            var sbCode = new StringBuilder();
            var connections = diagramViewModel.Items.OfType<ConnectorViewModel>();

            sbCode.AppendLine("//C++ class generated by CD2C(MC200202999)");
            sbCode.AppendLine("using namespace std;");
            sbCode.AppendLine();

            foreach (var classViewModel in diagramViewModel.Items.OfType<ClassDesignerItemViewModel>())
            {
                var connectionInfo = connections.
                    Where(con =>
                        con.SourceConnectorInfo.DataItem == classViewModel &&
                        con.SinkConnectorInfo is FullyCreatedConnectorInfo &&
                        con.IsFullConnection
                    ).
                    Select(con => new
                    {
                        ParentClassName = ((con.SinkConnectorInfo as FullyCreatedConnectorInfo).DataItem as ClassDesignerItemViewModel).ClassName,
                        Multiplicity = con.MultiplicityType,
                        ConnectionType = con.ConnectionType
                    }).
                    FirstOrDefault();

                string classCode =
                    GenerateClass(classViewModel.ClassName,
                        connectionInfo == null ? null : connectionInfo.ParentClassName,
                        connectionInfo == null ? ConnectionTypeEnum.Inheritance : connectionInfo.ConnectionType,
                        connectionInfo == null ? MultiplicityTypeEnum.Unspecified : connectionInfo.Multiplicity,
                        classViewModel.Methods,
                        classViewModel.DataMembers
                    );

                sbCode.AppendLine(classCode);
                sbCode.AppendLine();
            }

            return sbCode.ToString();
        }

        public string GenerateClass(string className, string parentClassName, ConnectionTypeEnum connectionType, MultiplicityTypeEnum multiplicityType, IEnumerable<MethodModel> methods, IEnumerable<DataMemberModel> dataMembers)
        {
            //Add members according to connection type and multiplicity.

            var allScopes = new List<ScopeEnum>();
            if (connectionType == ConnectionTypeEnum.Association || connectionType == ConnectionTypeEnum.Composition)
            {
                allScopes.Add(ScopeEnum.Public);
            }

            //Find unique scopes
            allScopes.AddRange(methods.Select(m => m.Scope));
            allScopes.AddRange(dataMembers.Select(dm => dm.Scope));
            allScopes = allScopes.Distinct().ToList();

            //Builder thats used to generate code as its best to create long string and has good formatting functions.
            var sbOutput = new StringBuilder();

            sbOutput.Append(string.Format("class {0}", className));
            
            if (connectionType == ConnectionTypeEnum.Inheritance && !string.IsNullOrEmpty(parentClassName))
            {
                sbOutput.Append(string.Format(" : public {0}", parentClassName));
            }

            sbOutput.AppendLine();
            sbOutput.AppendLine("{");

            var varCount = 0;
            foreach (var scope in allScopes)
            {
                sbOutput.AppendLine(string.Format("\t{0}:", scope.ToString().ToLower()));

                //find all members and methods of the current scope
                var scopeDataMembers = dataMembers.Where(dm => dm.Scope == scope).ToList();
                var scopeMethods = methods.Where(dm => dm.Scope == scope).ToList();

                if (scope == ScopeEnum.Public && !string.IsNullOrEmpty(parentClassName) && (connectionType == ConnectionTypeEnum.Association || connectionType == ConnectionTypeEnum.Composition))
                {
                    if (connectionType == ConnectionTypeEnum.Association)
                    {
                        sbOutput.AppendLine(string.Format("\t\t{0} var{1};", parentClassName, ++varCount));
                    }
                    else if (connectionType == ConnectionTypeEnum.Composition)
                    {
                        sbOutput.AppendLine(string.Format("\t\t{0}[] var{1};", parentClassName, ++varCount));
                    }
                }

                foreach (var dm in scopeDataMembers)
                {
                    sbOutput.AppendLine(string.Format("\t\t{0} {1};", GetProperTypeName(dm.Type), dm.Name));
                }

                foreach (var m in scopeMethods)
                {
                    var rows = m.InputParameters.Select(kv => string.Format("{1} {0}", kv.Name, kv.InputType.ToString().Replace("Type", string.Empty))).ToList();
                    var iParams = string.Join(", ", rows);

                    sbOutput.AppendLine(string.Format("\t\t{0} {1} ({2})", GetProperTypeName(m.ReturnType), m.Name, iParams));
                    sbOutput.AppendLine("\t\t{");
                    sbOutput.AppendLine();
                    sbOutput.AppendLine("\t\t}");
                }

                sbOutput.AppendLine();
            }


            sbOutput.AppendLine("};");

            return sbOutput.ToString();
        }

        string GetProperTypeName(TypeEnum typeEnum)
        {
            return typeEnum.ToString().Replace("Type", string.Empty).ToLower();
        }
    }
}
